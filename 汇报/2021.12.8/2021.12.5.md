## 1. 首先尝试按原方法 换边长较长、个数较少的棋盘格进行操作，结果依然误差较大。

![Inkedcalibresult4_LI](C:\Users\dell\Desktop\Courses\IPP\汇报\2021.12.8\Inkedcalibresult4_LI.jpg)

可以看到边缘还是有扭曲，尺子上端、棋盘格左下有明显扭曲。

分析可能原因：

### 1. undistort函数会将图片进行扭曲，而如果棋盘格占镜头太大，会受到影响。也许把棋盘格放的稍远一些会更好？

![img](https://images2015.cnblogs.com/blog/1138496/201704/1138496-20170414225209314-1805828765.png)

### 2. 之前的操作对于calibratecamera函数得到的 旋转、平移矢量（用于透视变换的）都没有使用，直接在某一张并不是水平面的照片上进行undistort变换和测量，并不能得到一个理想的棋盘格。应当先消除透视，再进行测量。

## 因此，进行以下操作：

借用原来obthomography函数进行消除透视，但对其具体参数设置并不是很理解。

size? ratio?

```python
def obthomography(dst, criteria, size=800, ratio=0.04):
    # Obtain homography of the picture centred at the centre of chessboard
    h, w = dst.shape[:2]
    gray = cv.cvtColor(dst, cv.COLOR_BGR2GRAY)
    '''image = dst
    size = image.shape
    gray1 = cv.cvtColor(
        image[math.ceil(size[0] / 3):math.ceil(2 * size[0] / 3), math.ceil(size[1] / 4):math.ceil(3 * size[1] / 4)],
        cv.COLOR_BGR2GRAY)'''
    # Find the chess board corners
    ret, corners = cv.findChessboardCorners(gray, (5, 5), None)
    '''for each in corners:
        if each is not None:
            each[0][1] += math.ceil(w / 3)
            each[0][0] += math.ceil(h / 4)'''
    # corners = cv.cornerSubPix(gray, corners, (11, 11), (-1, -1), criteria)
    # uncomment this line to perform subpixel detection of corner, significantly slow the speed
    # prepare corresponding points for homography
    objp2 = np.zeros((5 * 5, 2), np.float32)
    cap = max(h, w)
    k = np.mgrid[-2:3:1, -2:3:1].T.reshape(-1, 2)
    objp2[:, :2] = (k * ratio + 0.5) * cap
    pts1 = np.float32([corners[0][0], corners[4][0], corners[-1][0]])

    # rectify picture to proper orientation that make the bolts face downward
    vec = corners[4][0] - corners[0][0]
    tan = vec[1] / vec[0]
    # !! only basic cases considered !!
    if tan <= 1 and tan >= -1:
        if vec[0] >= 0:
            pts2 = np.float32([objp2[0], objp2[4], objp2[-1]])
        else:
            pts2 = np.float32([objp2[-1], objp2[-5], objp2[0]])
    else:
        if vec[1] >= 0:
            pts2 = np.float32([objp2[4], objp2[-1], objp2[-5]])
        else:
            pts2 = np.float32([objp2[-5], objp2[0], objp2[4]])

    # obtain and perform transformation
    M = cv.getAffineTransform(pts1, pts2)
    # H = cv.findHomography(corners, objp2)
    dst = cv.warpAffine(dst, M, (cap, cap))
    dst = cv.resize(dst, (size, size))
    return dst
```

我选择原来的参数，结果并不是很满意：

![result](D:\Courses\IPP\汇报\2021.12.8\result.png)
