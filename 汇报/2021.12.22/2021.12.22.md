## undistort 函数

```
undistort(src, cameraMatrix, distCoeffs[, dst[, newCameraMatrix]]) -> dst.   
@brief Transforms an image to compensate for lens distortion. The function transforms an image to compensate radial and tangential lens distortion.The function is simply a combination of #initUndistortRectifyMap (with unity R) and #remap(with bilinear interpolation). See the former function for details of the transformation being performed. Those pixels in the destination image, for which there is no correspondent pixels in the source image, are filled with zeros (black color). A particular subset of the source image that will be visible in the corrected image can be regulated by newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the appropriate.   newCameraMatrix depending on your requirements. The camera matrix and the distortion parameters can be determined using #calibrateCamera. If the resolution of images is different from the resolution used at the calibration stage, \f$f_x,f_y, c_x\f$ and \f$c_y\f$ need to be scaled accordingly, while the distortion coefficients remain the same.   
@param src Input (distorted) image.   
@param dst Output (corrected) image that has the same size and type as src
@param cameraMatrix Input camera matrix \f$A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\f$
@param distCoeffs Input vector of distortion coefficients \f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\f$ of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.
@param newCameraMatrix Camera matrix of the distorted image. By default, it is the same as cameraMatrix but you may additionally scale and shift the result by using a different matrix.
```

undistortion (src, cameraMatrix, distCoeffs[， dst[， newCameraMatrix]]) -> dst。  

@brief变换图像以补偿镜头失真。 **该函数对图像进行变换，以补偿径向和切向透镜的畸变。** 这个函数是# initundistortion trectifymap(带有unity R)和#remap(带有双线性插值)的简单组合。 有关正在执行的转换的详细信息，请参阅前一个函数。 目标图像中的像素(源图像中没有对应的像素)用0填充(黑色)。 源图像的特定子集将在校正后的图像中可见，可以通过newCameraMatrix进行调节。 你可以使用#getOptimalNewCameraMatrix来计算合适的。 newCameraMatrix根据您的要求。 相机矩阵和失真参数可以使用#calibrateCamera来确定。 如果图像的分辨率不同于在校准阶段使用的分辨率，\f$f_x,f_y, c_x\f$和\f$c_y\f$需要相应地缩放，而失真系数保持不变。  

输入(扭曲的)图像。  

@param dst输出与src相同大小和类型的(经过校正的)图像  

@param cameraMatrix输入相机矩阵\f$A = \ vecthrethree {f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\f$  

@param distCoeffs 4, 5, 8, 12或14个元素的失真系数的输入向量\f$(k_1, k_2, p_1, p_2[， k_3[， k_4, k_5, k_6[， s_1, s_2, s_3, s_4[， \tau_x， \tau_y]]]])\f$。 如果向量为NULL/空，则假定零失真系数。  

@param newCameraMatrix扭曲图像的相机矩阵。 默认情况下，它和cameraMatrix是一样的，但是你可以通过使用不同的矩阵来缩放和移动结果。  

## 和陆恒毅学长的沟通结果

关于obthomography函数的参数的一些解释

- size: 导出图片的分辨率

- ratio：相当于棋盘格上一格占图片宽度的比例

然后opencv的calibrateCamera可以消除扭曲但不能消除透视，因为只是单张图缺乏3d信息

obthomography消除的实际上是棋盘格所在平面的透视

除此以外，学长还提到base_grid2的算法有问题，但具体他等到周末再重新写

![1640142263189](C:\Users\14566\AppData\Roaming\Typora\typora-user-images\1640142263189.png)

### 自己尝试重新使用obthomography函数，对上一次相同的方法重新尝试一次，即先使用undistort函数进行相机矫正，然后试着进行透视变换。

除此以外有几点需要注意：

1. 出于简单考虑，我直接使用了原来的obthmography函数，该函数重复调用了findchessboard等函数，所以处理上可能会慢，可以进一步优化
2. 相比于上次只选取3张照片，我拍摄了9张照片进行处理

结果：

before:

![before](D:\Courses\IPP\汇报\2021.12.22\before.png)

after:

![after](D:\Courses\IPP\汇报\2021.12.22\after.png)

效果依旧较差，可能原因：

1. 相机标定进行鱼眼矫正的时候 左下角出现畸变，说明棋盘格不能很近
2. 这个透视变换可能依然存在问题

### 上网查询相关问题：

#### 关于相机标定的误差分析：CSDN

  2）至于不少人说OpenCV中用cvCalibrateCamera2 进行相机标定的精度差，标定结果不稳定，我想可能的原因有：

  原因之一）可能是在标定的时候标定板所在平面与成像平面(image plane)之间的夹角太小，张正友论文里的仿真数据(有噪声的数据)说明当两者夹角太小误差会很大， 从张正友的论文里给出的5幅图中（http://research.microsoft.com/~zhang/Calib/）其中标定平面与成像平面的夹角分别为：
8.8947 11.2325 24.4875 10.8535 9.5829（单位：度）。
  而且张正友的论文中也提到两幅标定板之间的位置平行放置的话，相关相当于一幅 因此在实际标定中平行放置的情况最好避免，可能有时你无形之中就犯了这个错误。

  原因之二）标定时拍摄的图片太少，虽然张正友的论文里只用了5幅图片，但是我建议搞个10来幅左右还是必要的，因为我们实际中可能标定板用A4的纸打印出来贴在一块板上的，标定板上的世界坐标精度就不是特别高，多拍摄几幅图像能减少这方面带来的误差，而且多个角度拍摄也可能解决了问题一：标定板和成像平面夹角小的问题。这个家伙用20幅来标定([http://www.vision.caltech.edu/bouguetj/ ... ample.html](http://www.vision.caltech.edu/bouguetj/))

  原因之三）图像上角点提取的不准确，我认为用cvFindChessboardCorners函数找角点不是很好，假如拍到的图像不是完整的棋盘格的时候肯定会有问题的，而且也不少人反应用这个函数提取不出角点，建议可以用其他工具 比如：
OpenCV and MatLab Camera Calibration Toolboxes Enhancement（http://graphics.cs.msu.ru/en/research/calibration/）
Camera Calibration Toolbox for Matlab（http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/example.html）★★★★★强烈推荐

   当然还有可能其他人为的什么原因。


  3）建议用其他方法比如Tsai的标定方法或其他的标定工具进行标定★★★★★强烈推荐用这个matlab标定工具箱来进行标定，可以和OpenCV做个对比嘛 ，它也是基于张正友的平面标定方法的，做得非常人性化，呵呵，有误差分析、标定结果三维重建、重投影计算角点等功能 。
Camera Calibration Toolbox for Matlab（http://www.vision.caltech.edu/bouguetj/calib_doc/） 

#### 基于此，下一步可以尝试matlab