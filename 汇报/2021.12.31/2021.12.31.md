## 1. 多角度照相问题

### 原来的函数/方法：

```python
pts1 = np.float32([corners[0][0], corners[10][0], corners[-1][0]])
###
pts2 = np.float32([objp2[0], objp2[10], objp2[-1]])
###
M = cv2.getAffineTransform(pts1, pts2)
    dst = cv2.warpAffine(dst, M, (cap, cap))
    dst = cv2.resize(dst, (size, size))
```

#### （1）角度较少+python

before 

<img src="D:\Courses\IPP\汇报\2021.12.31\conimg_6_9.jpg" alt="conimg_6_9" style="zoom:12%;" />

after:

<img src="D:\Courses\IPP\汇报\2021.12.31\calibresult6.jpg" alt="calibresult6" style="zoom:12%;" />

#### (2) 角度更多 + python

before:

<img src="D:\Courses\IPP\汇报\2021.12.31\conimg_7_9.jpg" alt="conimg_7_9" style="zoom: 12%;" />

after:

<img src="D:\Courses\IPP\汇报\2021.12.31\calibresult7.jpg" alt="calibresult7" style="zoom:12%;" />

##### 观察发现：其实三个角是做到了透视变换，但第四个角错误

##### 并且：在换成这个标定板之后，程序进程快了很多、并且亚像素抓取也能成功

原因：在python用来透视变换的 getAffineTransform、warpAffine的函数中，原做法是默认只选取三个角点作为参数来进行透视转换

猜想：会不会是因为没有取四个点呢？

尝试之后

```python
cv2.error: OpenCV(4.5.4) D:\a\opencv-python\opencv-python\opencv\modules\imgproc\src\imgwarp.cpp:3399: error: (-215:Assertion failed) src.checkVector(2, CV_32F) == 3 && dst.checkVector(2, CV_32F) == 3 in function 'cv::getAffineTransform'
```

报错信息可能是该函数只能读取三个点，这也是疑惑之处

## matlab + 多角度

##### 2 coefficients

before：

<img src="D:\Courses\IPP\汇报\2021.12.31\屏幕截图 2021-12-26 153105.png" alt="屏幕截图 2021-12-26 153105" style="zoom:28%;" />

after：

<img src="D:\Courses\IPP\汇报\2021.12.31\屏幕截图 2021-12-26 153116.png" alt="屏幕截图 2021-12-26 153116" style="zoom:28%;" />

##### matlab相关参数：

k1=0.0663, k2=-0.1161,p1=-6.3460e-04,p2=0.0012

Intrinsic matrix

3073.13236265387	  0	                               0
-0.817394308006153  3076.02046351433	0
1998.77398381345	 1523.24170174716	 1

##### 3 coefficients

after:

<img src="D:\Courses\IPP\汇报\2021.12.31\屏幕截图 2021-12-26 160548.png" alt="屏幕截图 2021-12-26 160548" style="zoom:28%;" />

matlab 参数：

k1=0.08, k2=-0.2645,p1=-6.4618e-04,p2=0.0011,k3=0.4395

Intrinsic matrix

3072.41079692931	0	                                    0
-0.837212467774263	3075.30124590746	 0
1998.67562494238	1523.12395371522	    1

#####  python 参数：

mtx:
 [[3.92686368e+03 0.00000000e+00 1.96473472e+03]
 [0.00000000e+00 3.92783814e+03 1.48359907e+03]
 [0.00000000e+00 0.00000000e+00 1.00000000e+00]]

转置之后：

 [[3.92686368e+03 0.00000000e+00 0.00000000e+00]
 [0.00000000e+00 3.92783814e+03 0.00000000e+00]
 [1.96473472e+03 1.48359907e+03 1.00000000e+00]]

dist:

k_1=0.10547693 ,k_2=-0.25395934 ,p_1=0.00123583 ,p_2=-0.00275257,k_3=-0.13621919

##### 用matlab进行透视变换：

before：

<img src="D:\Courses\IPP\汇报\2021.12.31\cut.jpg" alt="cut" style="zoom:50%;" />

after:![after](D:\Courses\IPP\汇报\2021.12.31\after.jpg)

看起来不错，但是有几个问题：

1. 图片质量较差
2. 需要手动选取四个点（尽管在相机标定部分它能显示出所有角点，但是没有找到办法能够导出这些坐标）
3. 自动化仍然需要探索

##### 接下来可能的工作：

1. 搞清楚python 变换透视的函数， 为什么只能选取三个点，有没有解决方案
2. 探索matlab，寻求自动化解决方案



matlab 代码：

```matlab
clear all;
close all;
clc;

img= imread('D:\Courses\IPP\matlab_test\cut.jpg');
img= rgb2gray(img);
imshow(mat2gray(img));
[M N] = size(img);

dot=ginput(4);       %取四个点，依次是左上，右上，左下，右下,这里我取的是书的四个角
w=round(sqrt((dot(1,1)-dot(2,1))^2+(dot(1,2)-dot(2,2))^2));     %从原四边形获得新矩形宽
h=round(sqrt((dot(1,1)-dot(3,1))^2+(dot(1,2)-dot(3,2))^2));     %从原四边形获得新矩形高

y=[dot(1,1) dot(2,1) dot(3,1) dot(4,1)];        %四个原顶点
x=[dot(1,2) dot(2,2) dot(3,2) dot(4,2)];

%这里是新的顶点，我取的矩形,也可以做成其他的形状
%大可以原图像是矩形，新图像是从dot中取得的点组成的任意四边形.:)
Y=[dot(1,1) dot(1,1) dot(1,1)+h dot(1,1)+h];     
X=[dot(1,2) dot(1,2)+w dot(1,2) dot(1,2)+w];

B=[X(1) Y(1) X(2) Y(2) X(3) Y(3) X(4) Y(4)]';   %变换后的四个顶点，方程右边的值
%联立解方程组，方程的系数
A=[x(1) y(1) 1 0 0 0 -X(1)*x(1) -X(1)*y(1);             
   0 0 0 x(1) y(1) 1 -Y(1)*x(1) -Y(1)*y(1);
   x(2) y(2) 1 0 0 0 -X(2)*x(2) -X(2)*y(2);
   0 0 0 x(2) y(2) 1 -Y(2)*x(2) -Y(2)*y(2);
   x(3) y(3) 1 0 0 0 -X(3)*x(3) -X(3)*y(3);
   0 0 0 x(3) y(3) 1 -Y(3)*x(3) -Y(3)*y(3);
   x(4) y(4) 1 0 0 0 -X(4)*x(4) -X(4)*y(4);
   0 0 0 x(4) y(4) 1 -Y(4)*x(4) -Y(4)*y(4)];

fa=inv(A)*B;        %用四点求得的方程的解，也是全局变换系数
a=fa(1);b=fa(2);c=fa(3);
d=fa(4);e=fa(5);f=fa(6);
g=fa(7);h=fa(8);

rot=[d e f;
     a b c;
     g h 1];        %公式中第一个数是x,Matlab第一个表示y，所以我矩阵1,2行互换了

pix1=rot*[1 1 1]'/(g*1+h*1+1);  %变换后图像左上点
pix2=rot*[1 N 1]'/(g*1+h*N+1);  %变换后图像右上点
pix3=rot*[M 1 1]'/(g*M+h*1+1);  %变换后图像左下点
pix4=rot*[M N 1]'/(g*M+h*N+1);  %变换后图像右下点

height=round(max([pix1(1) pix2(1) pix3(1) pix4(1)])-min([pix1(1) pix2(1) pix3(1) pix4(1)]));     %变换后图像的高度
width=round(max([pix1(2) pix2(2) pix3(2) pix4(2)])-min([pix1(2) pix2(2) pix3(2) pix4(2)]));      %变换后图像的宽度
imgn=zeros(height,width);

delta_y=round(abs(min([pix1(1) pix2(1) pix3(1) pix4(1)])));            %取得y方向的负轴超出的偏移量
delta_x=round(abs(min([pix1(2) pix2(2) pix3(2) pix4(2)])));            %取得x方向的负轴超出的偏移量
inv_rot=inv(rot);

for i = 1-delta_y:height-delta_y                        %从变换图像中反向寻找原图像的点，以免出现空洞，和旋转放大原理一样
    for j = 1-delta_x:width-delta_x
        pix=inv_rot*[i j 1]';       %求原图像中坐标，因为[YW XW W]=fa*[y x 1],所以这里求的是[YW XW W],W=gy+hx+1;
        pix=inv([g*pix(1)-1 h*pix(1);g*pix(2) h*pix(2)-1])*[-pix(1) -pix(2)]'; %相当于解[pix(1)*(gy+hx+1) pix(2)*(gy+hx+1)]=[y x],这样一个方程，求y和x，最后pix=[y x];
        
        if pix(1)>=0.5 && pix(2)>=0.5 && pix(1)<=M && pix(2)<=N
            imgn(i+delta_y,j+delta_x)=img(round(pix(1)),round(pix(2)));     %最邻近插值,也可以用双线性或双立方插值
        end  
    end
end

figure;
imshow(uint8(imgn));
```

